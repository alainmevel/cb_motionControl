/*2023-10-04T11:03:54-01:00*/

/********************************************************************
 * servo_position.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "servo_position.h"



/**************************** Variables *****************************/

CB_Index servo_position__num = 0;
CB_Mem_Bool *servo_position_MoveAbsEnable;
CB_Mem_Bool *servo_position_MoveAbsStart;
CB_Mem_Float *servo_position_MovePosition;
CB_Mem_Float *servo_position_MoveSpeed;
CB_Mem_Float *servo_position_MoveAcceleration;
CB_Mem_Float *servo_position_MoveDeceleration;
CB_Mem_Float *servo_position_MAX_SPEED;
CB_Mem_Float *servo_position_MAX_ACCEL;
CB_Mem_Float *servo_position_MAX_DECEL;
CB_Mem_Float *servo_position_MODULO_LENGTH;
CB_Mem_Int *servo_position_status;
CB_Mem_Int *servo_position_errorFlag;
CB_Mem_Bool *servo_position_MoveAbsDone;
CB_Mem_Float *servo_position_ActualPositionAx;
CB_Mem_Float *servo_position_ActualVelocity;
CB_Mem_Bool *servo_position_firstStep;
CB_Mem_Bool *servo_position_stepDone;
CB_Mem_Float *servo_position_timeToStop;
CB_Mem_Float *servo_position_distanceToStop;
CB_Mem_Float *servo_position_distance;
CB_Mem_Float *servo_position_currentTime;
CB_Mem_Float *servo_position_currentSpeed1;
CB_Mem_Float *servo_position_targetPosition;
CB_Mem_Float *servo_position_ActualPositionAx1;
CB_Mem_Float *servo_position_acceleration;
CB_Mem_Float *servo_position_deceleration;
CB_Mem_Float *servo_position_orderSpeed;
CB_Mem_Float *servo_position_moveDirection;
CB_Mem_Float *servo_position_moveDirection1;
CB_Mem_Float *servo_position_endChangeSpeed;
CB_Mem_Float *servo_position_ActualVelocity1;

/**************************** Variables *****************************/

#define MoveAbsEnable (servo_position_MoveAbsEnable->CB_current_value)
#define MoveAbsStart (servo_position_MoveAbsStart->CB_current_value)
#define MovePosition (servo_position_MovePosition->CB_current_value)
#define MoveSpeed (servo_position_MoveSpeed->CB_current_value)
#define MoveAcceleration (servo_position_MoveAcceleration->CB_current_value)
#define MoveDeceleration (servo_position_MoveDeceleration->CB_current_value)
#define MAX_SPEED (servo_position_MAX_SPEED->CB_current_value)
#define MAX_ACCEL (servo_position_MAX_ACCEL->CB_current_value)
#define MAX_DECEL (servo_position_MAX_DECEL->CB_current_value)
#define MODULO_LENGTH (servo_position_MODULO_LENGTH->CB_current_value)
#define status (*((short *)&(servo_position_status->CB_current_value) + ALIGN_OFFSET_SHORT))
#define errorFlag (*((short *)&(servo_position_errorFlag->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MoveAbsDone (servo_position_MoveAbsDone->CB_current_value)
#define ActualPositionAx (servo_position_ActualPositionAx->CB_current_value)
#define ActualVelocity (servo_position_ActualVelocity->CB_current_value)
#define firstStep (servo_position_firstStep->CB_current_value)
#define stepDone (servo_position_stepDone->CB_current_value)
#define timeToStop (servo_position_timeToStop->CB_current_value)
#define distanceToStop (servo_position_distanceToStop->CB_current_value)
#define distance (servo_position_distance->CB_current_value)
#define currentTime (servo_position_currentTime->CB_current_value)
#define currentSpeed1 (servo_position_currentSpeed1->CB_current_value)
#define targetPosition (servo_position_targetPosition->CB_current_value)
#define ActualPositionAx1 (servo_position_ActualPositionAx1->CB_current_value)
#define acceleration (servo_position_acceleration->CB_current_value)
#define deceleration (servo_position_deceleration->CB_current_value)
#define orderSpeed (servo_position_orderSpeed->CB_current_value)
#define moveDirection (servo_position_moveDirection->CB_current_value)
#define moveDirection1 (servo_position_moveDirection1->CB_current_value)
#define endChangeSpeed (servo_position_endChangeSpeed->CB_current_value)
#define ActualVelocity1 (servo_position_ActualVelocity1->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _motion_control__servo_position_init(void)
{
	(servo_position_MoveSpeed)->CB_current_value = 100.0; /*MoveSpeed*/
	(servo_position_MoveAcceleration)->CB_current_value = 100.0; /*MoveAcceleration*/
	(servo_position_MoveDeceleration)->CB_current_value = 100.0; /*MoveDeceleration*/
	(servo_position_MAX_SPEED)->CB_current_value = 1000.0; /*MAX_SPEED*/
	(servo_position_MAX_ACCEL)->CB_current_value = 300.0; /*MAX_ACCEL*/
	(servo_position_MAX_DECEL)->CB_current_value = 300.0; /*MAX_DECEL*/
	(self.Bool+0)->CB_current_value = 1; /*firstStep*/
	self.Bool+=2;
	self.Float+=14;


	return 0;
}


/************************ Behavior function *************************/

int motion_control__servo_position(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		servo_position_firstStep = self.Bool+0;
		servo_position_stepDone = self.Bool+1;
		servo_position_timeToStop = self.Float+0;
		servo_position_distanceToStop = self.Float+1;
		servo_position_distance = self.Float+2;
		servo_position_currentTime = self.Float+3;
		servo_position_currentSpeed1 = self.Float+4;
		servo_position_targetPosition = self.Float+5;
		servo_position_ActualPositionAx1 = self.Float+6;
		servo_position_acceleration = self.Float+7;
		servo_position_deceleration = self.Float+8;
		servo_position_orderSpeed = self.Float+9;
		servo_position_moveDirection = self.Float+10;
		servo_position_moveDirection1 = self.Float+11;
		servo_position_endChangeSpeed = self.Float+12;
		servo_position_ActualVelocity1 = self.Float+13;

		/********************* Pre-conditions execution *********************/

		if (allowpreconditions->CB_current_value) {
			if (!((0.0 <= MAX_SPEED) && (MAX_SPEED <= 3.4e+38))) {
				raise_debug_break(servo_position_MAX_SPEED - mem.Float, INPRE, OUTOFRANGESFLOAT, 0);
				return servo_position__num; /*assertion failure*/
			}
			if (!((0.0 <= MAX_ACCEL) && (MAX_ACCEL <= 3.4e+38))) {
				raise_debug_break(servo_position_MAX_ACCEL - mem.Float, INPRE, OUTOFRANGESFLOAT, 0);
				return servo_position__num; /*assertion failure*/
			}
			if (!((0.0 <= MAX_DECEL) && (MAX_DECEL <= 3.4e+38))) {
				raise_debug_break(servo_position_MAX_DECEL - mem.Float, INPRE, OUTOFRANGESFLOAT, 0);
				return servo_position__num; /*assertion failure*/
			}
		}

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  motion control						*/
			/* Author : 									*/
			/* Update date : June 2021							*/
			/* ----------------------------------------------------------------	*/
			/* This module controls positioning behavior of the motion drive	*/
			/* ----------------------------------------------------------------	*/ 
			stepDone = 0;

			if (MoveAbsEnable) {
				if (status == 0) {
					stepDone = 1;
					if (MoveAbsStart == 1) {
						errorFlag = 0;
						if (!(MoveAcceleration > 0 && MoveAcceleration <= 100.0)) {
							errorFlag = 1;
						}
						if (!(MoveDeceleration > 0 && MoveDeceleration <= 100.0)) {
							errorFlag = 2;
						}
						if (!(MoveSpeed >= -100.0 && MoveSpeed <= 100.0)) {
							errorFlag = 3;
						}
						if (errorFlag == 0) {
							targetPosition = MovePosition;
							status = 1;
							MoveAbsDone = 0;
							ActualVelocity = 0;
							currentTime = 0;
							acceleration = MoveAcceleration * MAX_ACCEL / 100.0; deceleration = MoveDeceleration * -MAX_DECEL / 100.0; orderSpeed = MoveSpeed * MAX_SPEED / 100.0;
							if (targetPosition == ActualPositionAx) { // test if movement is null
								status = 4;
							} else {
								if (targetPosition < ActualPositionAx) {
									acceleration = -MoveAcceleration * MAX_ACCEL / 100.0; deceleration = -MoveDeceleration * -MAX_DECEL / 100.0; orderSpeed = -MoveSpeed * MAX_SPEED / 100.0;
								}
								endChangeSpeed = orderSpeed  / acceleration;
								// test if movement is very small
								ActualVelocity = ActualVelocity + acceleration * CLOCK_PERIOD/1000000;
								if (orderSpeed > 0 && ActualVelocity > orderSpeed) ActualVelocity = orderSpeed;
								if (orderSpeed < 0 && ActualVelocity < orderSpeed) ActualVelocity = orderSpeed;
								ActualPositionAx = ActualPositionAx + ActualVelocity * CLOCK_PERIOD/1000000;
								distance = (acceleration > 0 ? 1.0 : -1.0) * (targetPosition - ActualPositionAx);
								if ( distance < 0) {
									status = 4;
								}
							}
						}
					}
				}
				
				if (status == 1 && stepDone == 0) { // Acceleration
					stepDone = 1;
					ActualVelocity = ActualVelocity + acceleration * CLOCK_PERIOD/1000000;
					if (orderSpeed > 0 && ActualVelocity > orderSpeed) ActualVelocity = orderSpeed;
					if (orderSpeed < 0 && ActualVelocity < orderSpeed) ActualVelocity = orderSpeed;
					ActualPositionAx = ActualPositionAx + ActualVelocity * CLOCK_PERIOD/1000000;
					timeToStop = fabs(ActualVelocity  / deceleration);
					distanceToStop = (deceleration < 0 ? -1.0 : 1.0) * 0.5 * deceleration * timeToStop * timeToStop;
					distance = (acceleration > 0 ? 1.0 : -1.0) * (targetPosition - ActualPositionAx);
					if (distance <= distanceToStop) {
						status = 3;
					}
					if (currentTime > endChangeSpeed) {
						ActualVelocity = orderSpeed;
						status = 2;
					}
					if (MoveAbsStart == 0 || MoveAbsEnable == 0) {
						status = 6;
					}
				}
				if (status == 2 && stepDone == 0) { // constant speed
					stepDone = 1;
					ActualVelocity = orderSpeed;
					ActualPositionAx = ActualPositionAx + ActualVelocity * CLOCK_PERIOD/1000000;
					timeToStop = fabs(ActualVelocity  / deceleration);
					distanceToStop = (deceleration < 0 ? -1.0 : 1.0) * 0.5 * deceleration * timeToStop * timeToStop;
					distance = (acceleration > 0 ? 1.0 : -1.0) * (targetPosition - ActualPositionAx);
					if (distance <= distanceToStop) {
						status = 3;
					}
					if (MoveAbsStart == 0 || MoveAbsEnable == 0) {
						status = 6;
					}
				}
				if (status == 3 && stepDone == 0) { // deceleration
					stepDone = 1;
					ActualVelocity = ActualVelocity + deceleration * CLOCK_PERIOD/1000000;
					if ((ActualVelocity * deceleration ) >= 0.0) {
						ActualVelocity = currentSpeed1;
					}
					ActualPositionAx = ActualPositionAx + ActualVelocity * CLOCK_PERIOD/1000000;
					timeToStop = fabs(ActualVelocity  / deceleration);
					distanceToStop = (deceleration < 0 ? -1.0 : 1.0) * 0.5 * deceleration * timeToStop * timeToStop;
					distance = (acceleration > 0 ? 1.0 : -1.0) * (targetPosition - ActualPositionAx);
					if ( distance < 0) {
						ActualPositionAx = targetPosition;
						status = 4;
					}
					if (MoveAbsStart == 0 || MoveAbsEnable == 0) {
						status = 6;
					}
				}
				if (status == 4 && stepDone == 0) { // movement succedeed - end OK
					stepDone = 1;
					MoveAbsDone = 1;
					ActualPositionAx = targetPosition;
					ActualVelocity = 0.0;
					status = 5;
				}
				
				if (status == 5 && stepDone == 0) { // terminate protocol handshaking
					stepDone = 1;
					if (MoveAbsStart == 0) {
						MoveAbsDone = 0;
						status = 0;
					}
				}

				if (status == 6 && stepDone == 0) { // movement aborted - deceleration - not reached the position
					stepDone = 1;
					ActualVelocity = ActualVelocity + deceleration * CLOCK_PERIOD/1000000;
					ActualPositionAx = ActualPositionAx + ActualVelocity * CLOCK_PERIOD/1000000;
					if (ActualVelocity1 * ActualVelocity <= 0.0) {
						ActualVelocity = 0;
						status = 0;
					}
				}
			}

			moveDirection = ActualPositionAx - ActualPositionAx1;

			ActualPositionAx1 = ActualPositionAx;
			moveDirection1 = moveDirection;
			ActualVelocity1 = ActualVelocity;
			currentTime += CLOCK_PERIOD/1000000;
			currentSpeed1 = ActualVelocity;

			firstStep = 0;




		}


		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 2;
	self.Float += 14;

	return 0;
}


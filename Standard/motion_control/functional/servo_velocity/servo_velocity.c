/*2023-10-04T11:03:54-01:00*/

/********************************************************************
 * servo_velocity.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "servo_velocity.h"



/**************************** Variables *****************************/

CB_Index servo_velocity__num = 0;
CB_Mem_Bool *servo_velocity_MoveVelEnable;
CB_Mem_Bool *servo_velocity_MoveVelStart;
CB_Mem_Float *servo_velocity_MoveSpeed;
CB_Mem_Float *servo_velocity_MoveAcceleration;
CB_Mem_Float *servo_velocity_MoveDeceleration;
CB_Mem_Float *servo_velocity_MAX_SPEED;
CB_Mem_Float *servo_velocity_MAX_ACCEL;
CB_Mem_Float *servo_velocity_MAX_DECEL;
CB_Mem_Float *servo_velocity_MODULO_LENGTH;
CB_Mem_Int *servo_velocity_status;
CB_Mem_Int *servo_velocity_errorFlag;
CB_Mem_Bool *servo_velocity_MoveVelDone;
CB_Mem_Float *servo_velocity_ActualPositionAx;
CB_Mem_Float *servo_velocity_ActualVelocity;
CB_Mem_Bool *servo_velocity_firstStep;
CB_Mem_Bool *servo_velocity_stepDone;
CB_Mem_Float *servo_velocity_currentTime;
CB_Mem_Float *servo_velocity_MoveSpeed1;
CB_Mem_Float *servo_velocity_acceleration;
CB_Mem_Float *servo_velocity_deceleration;
CB_Mem_Float *servo_velocity_orderSpeed;
CB_Mem_Float *servo_velocity_endChangeSpeed;
CB_Mem_Float *servo_velocity_accelDecelChangeSpeed;
CB_Mem_Float *servo_velocity_ActualVelocity1;
CB_Mem_Bool *servo_velocity_speedChanged;

/**************************** Variables *****************************/

#define MoveVelEnable (servo_velocity_MoveVelEnable->CB_current_value)
#define MoveVelStart (servo_velocity_MoveVelStart->CB_current_value)
#define MoveSpeed (servo_velocity_MoveSpeed->CB_current_value)
#define MoveAcceleration (servo_velocity_MoveAcceleration->CB_current_value)
#define MoveDeceleration (servo_velocity_MoveDeceleration->CB_current_value)
#define MAX_SPEED (servo_velocity_MAX_SPEED->CB_current_value)
#define MAX_ACCEL (servo_velocity_MAX_ACCEL->CB_current_value)
#define MAX_DECEL (servo_velocity_MAX_DECEL->CB_current_value)
#define MODULO_LENGTH (servo_velocity_MODULO_LENGTH->CB_current_value)
#define status (*((short *)&(servo_velocity_status->CB_current_value) + ALIGN_OFFSET_SHORT))
#define errorFlag (*((short *)&(servo_velocity_errorFlag->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MoveVelDone (servo_velocity_MoveVelDone->CB_current_value)
#define ActualPositionAx (servo_velocity_ActualPositionAx->CB_current_value)
#define ActualVelocity (servo_velocity_ActualVelocity->CB_current_value)
#define firstStep (servo_velocity_firstStep->CB_current_value)
#define stepDone (servo_velocity_stepDone->CB_current_value)
#define currentTime (servo_velocity_currentTime->CB_current_value)
#define MoveSpeed1 (servo_velocity_MoveSpeed1->CB_current_value)
#define acceleration (servo_velocity_acceleration->CB_current_value)
#define deceleration (servo_velocity_deceleration->CB_current_value)
#define orderSpeed (servo_velocity_orderSpeed->CB_current_value)
#define endChangeSpeed (servo_velocity_endChangeSpeed->CB_current_value)
#define accelDecelChangeSpeed (servo_velocity_accelDecelChangeSpeed->CB_current_value)
#define ActualVelocity1 (servo_velocity_ActualVelocity1->CB_current_value)
#define speedChanged (servo_velocity_speedChanged->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _motion_control__servo_velocity_init(void)
{
	(servo_velocity_MoveSpeed)->CB_current_value = 100.0; /*MoveSpeed*/
	(servo_velocity_MoveAcceleration)->CB_current_value = 100.0; /*MoveAcceleration*/
	(servo_velocity_MoveDeceleration)->CB_current_value = 100.0; /*MoveDeceleration*/
	(servo_velocity_MAX_SPEED)->CB_current_value = 1000.0; /*MAX_SPEED*/
	(servo_velocity_MAX_ACCEL)->CB_current_value = 300.0; /*MAX_ACCEL*/
	(servo_velocity_MAX_DECEL)->CB_current_value = 300.0; /*MAX_DECEL*/
	(self.Bool+0)->CB_current_value = 1; /*firstStep*/
	self.Bool+=3;
	self.Float+=8;


	return 0;
}


/************************ Behavior function *************************/

int motion_control__servo_velocity(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		servo_velocity_firstStep = self.Bool+0;
		servo_velocity_stepDone = self.Bool+1;
		servo_velocity_currentTime = self.Float+0;
		servo_velocity_MoveSpeed1 = self.Float+1;
		servo_velocity_acceleration = self.Float+2;
		servo_velocity_deceleration = self.Float+3;
		servo_velocity_orderSpeed = self.Float+4;
		servo_velocity_endChangeSpeed = self.Float+5;
		servo_velocity_accelDecelChangeSpeed = self.Float+6;
		servo_velocity_ActualVelocity1 = self.Float+7;
		servo_velocity_speedChanged = self.Bool+2;

		/********************* Pre-conditions execution *********************/

		if (allowpreconditions->CB_current_value) {
			if (!((0.0 <= MAX_SPEED) && (MAX_SPEED <= 3.4e+38))) {
				raise_debug_break(servo_velocity_MAX_SPEED - mem.Float, INPRE, OUTOFRANGESFLOAT, 0);
				return servo_velocity__num; /*assertion failure*/
			}
			if (!((0.0 <= MAX_ACCEL) && (MAX_ACCEL <= 3.4e+38))) {
				raise_debug_break(servo_velocity_MAX_ACCEL - mem.Float, INPRE, OUTOFRANGESFLOAT, 0);
				return servo_velocity__num; /*assertion failure*/
			}
			if (!((0.0 <= MAX_DECEL) && (MAX_DECEL <= 3.4e+38))) {
				raise_debug_break(servo_velocity_MAX_DECEL - mem.Float, INPRE, OUTOFRANGESFLOAT, 0);
				return servo_velocity__num; /*assertion failure*/
			}
		}

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  motion control						*/
			/* Author : 									*/
			/* Update date : June 2021							*/
			/* ----------------------------------------------------------------	*/
			/* This module controls velocity behavior of the motion drive	 	*/
			/* ----------------------------------------------------------------	*/

			stepDone = 0;
			if (MoveVelEnable) {
				if (status == 0) {
					stepDone = 1;
					if (MoveVelStart == 1) {
						errorFlag = 0;
						if (!(MoveAcceleration > 0 && MoveAcceleration <= 100.0)) {
							errorFlag = 1;
						}
						if (!(MoveDeceleration > 0 && MoveDeceleration <= 100.0)) {
							errorFlag = 2;
						}
						if (!(MoveSpeed >= -100.0 && MoveSpeed <= 100.0)) {
							errorFlag = 3;
						}
						if (errorFlag == 0) {
							status = 1;
							MoveVelDone = 0;
							ActualVelocity = 0;
							speedChanged = 1;
						}
					}
				}
				if (status != 0) {
					if (MoveSpeed1 != MoveSpeed || speedChanged != 0) {
						speedChanged = 0;
						currentTime = 0;
						orderSpeed = MoveSpeed * MAX_SPEED / 100.0;
						if (MoveSpeed >= 0) {
							acceleration = +MoveAcceleration * MAX_ACCEL / 100.0;
							deceleration = +MoveDeceleration * -MAX_DECEL / 100.0;
							accelDecelChangeSpeed = ActualVelocity > orderSpeed  ? deceleration : acceleration;
						} else {
							acceleration = -MoveAcceleration * MAX_ACCEL / 100.0; 
							deceleration = -MoveDeceleration * -MAX_DECEL / 100.0;
							accelDecelChangeSpeed = ActualVelocity > orderSpeed  ? acceleration : deceleration;
						}
						endChangeSpeed = fabs((orderSpeed - ActualVelocity) / accelDecelChangeSpeed);
						status = 1;
					}
				}
				if (status == 1 && stepDone == 0) { // CHANGE SPEED
					stepDone = 1;
					ActualVelocity = ActualVelocity + accelDecelChangeSpeed * CLOCK_PERIOD/1000000;
					if (currentTime > endChangeSpeed) {
						ActualVelocity = orderSpeed;
						status = 2;
					}
					if (MoveVelStart == 0) {
						status = 3;
					}
				}
				if (status == 2 && stepDone == 0) { // CONSTANT SPEED
					stepDone = 1;
					ActualVelocity = orderSpeed;
					if (MoveVelStart == 0) {
						status = 3;
					}
				}
				if (status == 3 && stepDone == 0) { // DECELERATION TO STOP
					stepDone = 1;
					ActualVelocity = ActualVelocity + deceleration * CLOCK_PERIOD/1000000;
					if (ActualVelocity1 * ActualVelocity <= 0.0) {
						ActualVelocity = 0.0;
						status = 4;
					}
					if (MoveVelStart != 0) {
						status = 1;
						speedChanged = 1;
					}
				}
				if (status == 4 && stepDone == 0) { // END
					stepDone = 1;
					ActualVelocity = 0.0;
					status = 0;
					MoveVelDone = 1;
				}
				if (status != 0) {
					ActualPositionAx = ActualPositionAx + ActualVelocity * CLOCK_PERIOD/1000000;
					if (MODULO_LENGTH != 0.0 ) {
						if (ActualPositionAx > MODULO_LENGTH) {
							ActualPositionAx = ActualPositionAx - MODULO_LENGTH;
						}
						if (ActualPositionAx < 0.0) {
							ActualPositionAx = ActualPositionAx + MODULO_LENGTH;
						}
						if (fabs(ActualVelocity * CLOCK_PERIOD/1000000) > MODULO_LENGTH/2.0) {
							errorFlag = 4;
						}
					}
				}
			}

			ActualVelocity1 = ActualVelocity;
			MoveSpeed1 = MoveSpeed;
			currentTime += CLOCK_PERIOD/1000000;

			firstStep = 0;
		}


		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 3;
	self.Float += 8;

	return 0;
}


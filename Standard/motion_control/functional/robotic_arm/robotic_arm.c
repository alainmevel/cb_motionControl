/*2023-10-04T11:03:56-01:00*/

/********************************************************************
 * robotic_arm.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"
#include "cb_products_iec.h"

#include "robotic_arm.h"


#define ROT_REFZ 5000.0// offset of the Z position used for intermediate rotations

#pragma once
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <assert.h>

typedef struct Quaternion {
	double w;	   /**< Scalar part */
	double v[3];	/**< Vector part */
} Quaternion;

void Quaternion_fromAxisAngle(double axis[3], double angle, Quaternion* output);
double Quaternion_norm(Quaternion* q);
void Quaternion_normalize(Quaternion* q, Quaternion* output);
void Quaternion_multiply(Quaternion* q1, Quaternion* q2, Quaternion* output);
void Quaternion_rotate(Quaternion* q, double v[3], double output[3]);

void Quaternion_set(double w, double v1, double v2, double v3, Quaternion* output) {
	output->w = w;
	output->v[0] = v1;
	output->v[1] = v2;
	output->v[2] = v3;
}

void Quaternion_fromAxisAngle(double axis[3], double angle, Quaternion* output) {
	output->w = cos(angle / 2.0);
	double c = sin(angle / 2.0);
	output->v[0] = c * axis[0];
	output->v[1] = c * axis[1];
	output->v[2] = c * axis[2];
}

double Quaternion_norm(Quaternion* q) {
	return sqrt(q->w*q->w + q->v[0]*q->v[0] + q->v[1]*q->v[1] + q->v[2]*q->v[2]);
}

void Quaternion_normalize(Quaternion* q, Quaternion* output) {
	double len = Quaternion_norm(q);
	Quaternion_set(
		q->w / len,
		q->v[0] / len,
		q->v[1] / len,
		q->v[2] / len,
		output);
}

void Quaternion_multiply(Quaternion* q1, Quaternion* q2, Quaternion* output) {
	assert(output != NULL);
	Quaternion result;
	result.w =	q1->w * q2->w - q1->v[0] * q2->v[0] - q1->v[1] * q2->v[1] - q1->v[2] * q2->v[2];
	result.v[0] = q1->v[0] * q2->w + q1->w * q2->v[0] + q1->v[1] * q2->v[2] - q1->v[2] * q2->v[1];
	result.v[1] = q1->w * q2->v[1] - q1->v[0] * q2->v[2] + q1->v[1] * q2->w + q1->v[2] * q2->v[0];
	result.v[2] = q1->w * q2->v[2] + q1->v[0] * q2->v[1] - q1->v[1] * q2->v[0] + q1->v[2] * q2->w   ;

	*output = result;
}

void Quaternion_rotate(Quaternion* q, double v[3], double output[3]) {
	assert(output != NULL);
	double result[3];

	double ww = q->w * q->w;
	double xx = q->v[0] * q->v[0];
	double yy = q->v[1] * q->v[1];
	double zz = q->v[2] * q->v[2];
	double wx = q->w * q->v[0];
	double wy = q->w * q->v[1];
	double wz = q->w * q->v[2];
	double xy = q->v[0] * q->v[1];
	double xz = q->v[0] * q->v[2];
	double yz = q->v[1] * q->v[2];

	result[0] = ww*v[0] + 2*wy*v[2] - 2*wz*v[1] +
				xx*v[0] + 2*xy*v[1] + 2*xz*v[2] -
				zz*v[0] - yy*v[0];
	result[1] = 2*xy*v[0] + yy*v[1] + 2*yz*v[2] +
				2*wz*v[0] - zz*v[1] + ww*v[1] -
				2*wx*v[2] - xx*v[1];
	result[2] = 2*xz*v[0] + 2*yz*v[1] + zz*v[2] -
				2*wy*v[0] - yy*v[2] + 2*wx*v[1] -
				xx*v[2] + ww*v[2];

	output[0] = result[0];
	output[1] = result[1];
	output[2] = result[2];
}

void Quaternion_toEulerZYX(Quaternion* q, double output[3]) {
	assert(output != NULL);

	// Roll (x-axis rotation)
	double sinr_cosp = +2.0 * (q->w * q->v[0] + q->v[1] * q->v[2]);
	double cosr_cosp = +1.0 - 2.0 * (q->v[0] * q->v[0] + q->v[1] * q->v[1]);
	output[0] = atan2(sinr_cosp, cosr_cosp);
	

	// Pitch (y-axis rotation)
	double sinp = +2.0 * (q->w * q->v[1] - q->v[2] * q->v[0]);
	if (fabs(sinp) >= 1)
		output[1] = copysign(M_PI / 2, sinp); // use 90 degrees if out of range
	else
		output[1] = asin(sinp);

	// Yaw (z-axis rotation)
	double siny_cosp = +2.0 * (q->w * q->v[2] + q->v[0] * q->v[1]);
	double cosy_cosp = +1.0 - 2.0 * (q->v[1] * q->v[1] + q->v[2] * q->v[2]);
	output[2] = atan2(siny_cosp, cosy_cosp);
}

/**************************** Variables *****************************/

CB_Index robotic_arm__num = 0;
CB_Mem_Float *robotic_arm_armOrigin;
CB_Mem_Float *robotic_arm_overallArmQuatInput;
CB_Mem_Float *robotic_arm_structRotVector;
CB_Mem_Float *robotic_arm_structRotDeg;
CB_Mem_Float *robotic_arm_driveRotVector;
CB_Mem_Float *robotic_arm_driveRotDeg;
CB_Mem_Float *robotic_arm_ownRotDeg;
CB_Mem_Float *robotic_arm_driveResizeLength;
CB_Mem_Bool *robotic_arm_functionActive;
CB_Mem_Float *robotic_arm_armExtrem;
CB_Mem_Float *robotic_arm_overallArmRotOutput;
CB_Mem_Int *robotic_arm_productId;
CB_Mem_Int *robotic_arm_status_act_prod;
CB_Mem_Float *robotic_arm_m11;
CB_Mem_Float *robotic_arm_m12;
CB_Mem_Float *robotic_arm_m13;
CB_Mem_Float *robotic_arm_m14;
CB_Mem_Float *robotic_arm_m21;
CB_Mem_Float *robotic_arm_m22;
CB_Mem_Float *robotic_arm_m23;
CB_Mem_Float *robotic_arm_m24;
CB_Mem_Float *robotic_arm_m31;
CB_Mem_Float *robotic_arm_m32;
CB_Mem_Float *robotic_arm_m33;
CB_Mem_Float *robotic_arm_m34;
CB_Mem_Float *robotic_arm_m41;
CB_Mem_Float *robotic_arm_m42;
CB_Mem_Float *robotic_arm_m43;
CB_Mem_Float *robotic_arm_m44;
CB_Mem_Float *robotic_arm_armLengthCalc;
CB_Mem_Bool *robotic_arm_functionActiveLocale;
CB_Mem_Int *robotic_arm_product_id;
CB_Mem_Int *robotic_arm_arm_id;
CB_Mem_Float *robotic_arm_timeToGripParam;
CB_Mem_Float *robotic_arm_armLength;
CB_Mem_Float *robotic_arm_armWidth;
CB_Mem_Float *robotic_arm_armHeight;
CB_Mem_Int *robotic_arm_armType;

/**************************** Variables *****************************/

#define armOrigin(i) (robotic_arm_armOrigin[i+1].CB_current_value)
#define overallArmQuatInput(i) (robotic_arm_overallArmQuatInput[i+1].CB_current_value)
#define structRotVector(i) (robotic_arm_structRotVector[i+1].CB_current_value)
#define structRotDeg (robotic_arm_structRotDeg->CB_current_value)
#define driveRotVector(i) (robotic_arm_driveRotVector[i+1].CB_current_value)
#define driveRotDeg (robotic_arm_driveRotDeg->CB_current_value)
#define ownRotDeg (robotic_arm_ownRotDeg->CB_current_value)
#define driveResizeLength (robotic_arm_driveResizeLength->CB_current_value)
#define functionActive (robotic_arm_functionActive->CB_current_value)
#define armExtrem(i) (robotic_arm_armExtrem[i+1].CB_current_value)
#define overallArmRotOutput(i) (robotic_arm_overallArmRotOutput[i+1].CB_current_value)
#define productId (robotic_arm_productId->CB_current_value)
#define status_act_prod (robotic_arm_status_act_prod->CB_current_value)
#define m11 (robotic_arm_m11->CB_current_value)
#define m12 (robotic_arm_m12->CB_current_value)
#define m13 (robotic_arm_m13->CB_current_value)
#define m14 (robotic_arm_m14->CB_current_value)
#define m21 (robotic_arm_m21->CB_current_value)
#define m22 (robotic_arm_m22->CB_current_value)
#define m23 (robotic_arm_m23->CB_current_value)
#define m24 (robotic_arm_m24->CB_current_value)
#define m31 (robotic_arm_m31->CB_current_value)
#define m32 (robotic_arm_m32->CB_current_value)
#define m33 (robotic_arm_m33->CB_current_value)
#define m34 (robotic_arm_m34->CB_current_value)
#define m41 (robotic_arm_m41->CB_current_value)
#define m42 (robotic_arm_m42->CB_current_value)
#define m43 (robotic_arm_m43->CB_current_value)
#define m44 (robotic_arm_m44->CB_current_value)
#define armLengthCalc (robotic_arm_armLengthCalc->CB_current_value)
#define functionActiveLocale (robotic_arm_functionActiveLocale->CB_current_value)
#define product_id (robotic_arm_product_id->CB_current_value)
#define arm_id (robotic_arm_arm_id->CB_current_value)
#define timeToGripParam (robotic_arm_timeToGripParam->CB_current_value)
#define armLength (robotic_arm_armLength->CB_current_value)
#define armWidth (robotic_arm_armWidth->CB_current_value)
#define armHeight (robotic_arm_armHeight->CB_current_value)
#define armType (*((short *)&(robotic_arm_armType->CB_current_value) + ALIGN_OFFSET_SHORT))


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _motion_control__robotic_arm_init(void)
{
	(robotic_arm_armOrigin+2)->CB_current_value = 235.0; /*armOrigin[1]*/
	(robotic_arm_armOrigin+3)->CB_current_value = 100.0; /*armOrigin[2]*/
	(robotic_arm_armOrigin+4)->CB_current_value = 100.0; /*armOrigin[3]*/
	(robotic_arm_overallArmQuatInput+2)->CB_current_value = 1.0; /*overallArmQuatInput[1]*/
	(robotic_arm_structRotVector+4)->CB_current_value = 1.0; /*structRotVector[3]*/
	(robotic_arm_driveRotVector+4)->CB_current_value = 1.0; /*driveRotVector[3]*/
	(robotic_arm_productId)->CB_current_value = (-1); /*productId*/
	(self.Float+0)->CB_current_value = 1.0; /*m11*/
	(self.Float+5)->CB_current_value = 1.0; /*m22*/
	(self.Float+10)->CB_current_value = 1.0; /*m33*/
	(self.Float+15)->CB_current_value = 1.0; /*m44*/
	(self.Int+1)->CB_current_value = (-1); /*product_id*/
	(self.Int+2)->CB_current_value = (-1); /*arm_id*/
	(self.Float+17)->CB_current_value = 0.15; /*timeToGripParam*/
	(self.Float+18)->CB_current_value = 100.0; /*armLength*/
	(self.Float+19)->CB_current_value = 5.0; /*armWidth*/
	(self.Float+20)->CB_current_value = 5.0; /*armHeight*/
	self.Bool+=1;
	self.Int+=4;
	self.Float+=21;


	return 0;
}


/************************ Behavior function *************************/

int motion_control__robotic_arm(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		robotic_arm_status_act_prod = self.Int+0;
		robotic_arm_m11 = self.Float+0;
		robotic_arm_m12 = self.Float+1;
		robotic_arm_m13 = self.Float+2;
		robotic_arm_m14 = self.Float+3;
		robotic_arm_m21 = self.Float+4;
		robotic_arm_m22 = self.Float+5;
		robotic_arm_m23 = self.Float+6;
		robotic_arm_m24 = self.Float+7;
		robotic_arm_m31 = self.Float+8;
		robotic_arm_m32 = self.Float+9;
		robotic_arm_m33 = self.Float+10;
		robotic_arm_m34 = self.Float+11;
		robotic_arm_m41 = self.Float+12;
		robotic_arm_m42 = self.Float+13;
		robotic_arm_m43 = self.Float+14;
		robotic_arm_m44 = self.Float+15;
		robotic_arm_armLengthCalc = self.Float+16;
		robotic_arm_functionActiveLocale = self.Bool+0;
		robotic_arm_product_id = self.Int+1;
		robotic_arm_arm_id = self.Int+2;
		robotic_arm_timeToGripParam = self.Float+17;
		robotic_arm_armLength = self.Float+18;
		robotic_arm_armWidth = self.Float+19;
		robotic_arm_armHeight = self.Float+20;
		robotic_arm_armType = self.Int+3;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Actor Myself init *************************/

		setMyselfFor(self_num);

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Motion control						*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2021							*/
			/* ----------------------------------------------------------------	*/
			/* This module simulates the behaviour of a robotic arm		*/
			/* ----------------------------------------------------------------	*/

			arm_id = myself;
			productId = product_id; // copy to output for miscelleanous use
			product_id = -1;
			functionActiveLocale = functionActive;

			armLengthCalc = armLength + driveResizeLength;
			if (armLengthCalc < 0.0) armLengthCalc = 0.0;

			// *** position of current arm relatively to origin ***
			double extrem[3];
			extrem[0] = armLengthCalc;
			extrem[1] = 0;
			extrem[2] = 0;

			// *** Compute structRotation applying structRotDeg ***
			double structAxis[3];
			Quaternion structRotation;
			structAxis[0] = structRotVector(1); structAxis[1] = structRotVector(2); structAxis[2] = structRotVector(3);
			Quaternion_fromAxisAngle(structAxis, structRotDeg*M_PI/180, &structRotation);
			Quaternion_normalize(&structRotation, &structRotation);

			// *** Compute rotation applying driveRotDeg & ownRotDeg ***
			double axis[3];
			Quaternion rotation;
			axis[0] = driveRotVector(1); axis[1] = driveRotVector(2); axis[2] = driveRotVector(3);
			Quaternion_fromAxisAngle(axis, (driveRotDeg + ownRotDeg)*M_PI/180, &rotation);
			Quaternion_normalize(&rotation, &rotation);

			// *** Get overall quaterniom coming from previous arm ***
			Quaternion overall;
			overall.w = overallArmQuatInput(1); //w 
			overall.v[0] = overallArmQuatInput(2); //cx 
			overall.v[1] = overallArmQuatInput(3); //cy 
			overall.v[2] = overallArmQuatInput(4); //cz

			// *** Add current rotations to get next overall quaternion ***
			Quaternion_multiply(&overall, &structRotation, &overall);
			Quaternion_multiply(&overall, &rotation, &overall);
			overallArmRotOutput(1) = overall.w;
			overallArmRotOutput(2) = overall.v[0];
			overallArmRotOutput(3) = overall.v[1];
			overallArmRotOutput(4) = overall.v[2];

			// *** Apply overall rotation to current arm relatively to origin
			Quaternion_rotate(&overall, extrem, extrem); 

			// *** Shift current arm to previous arm extremity ***
			armExtrem(1) = armOrigin(1) + extrem[0];
			armExtrem(2) = armOrigin(2) + extrem[1];
			armExtrem(3) = armOrigin(3) + extrem[2];

			// *** display in ControlBuild coordinate system ***
			double eulerAngles[3];
			Quaternion_toEulerZYX(&overall , eulerAngles);

			if (armLengthCalc == 0.0) armLengthCalc = 0.001;
			resizeTo(myself, armLengthCalc, armWidth, armHeight);

			rotateTo(myself,0.0 , 0.0 , 0.0, 0.0, 0.0, 0.0);
			moveTo(myself, 0.0, -armWidth/2.0, ROT_REFZ-armHeight/2.0);
			rotateBy(myself,eulerAngles[0]*180/M_PI ,eulerAngles[1]*180/M_PI ,eulerAngles[2]*180/M_PI, 0.0, 0.0, ROT_REFZ);
			moveBy(myself, armOrigin(1), armOrigin(2), armOrigin(3)-ROT_REFZ); 



		}

		{int _k; for (_k = 2; _k < 5; _k++) { CB_post_float(robotic_arm_armExtrem+_k); }}
		{int _k; for (_k = 2; _k < 6; _k++) { CB_post_float(robotic_arm_overallArmRotOutput+_k); }}
		CB_post_int(robotic_arm_productId);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 1;
	self.Int += 4;
	self.Float += 21;

	return 0;
}


/*2023-10-04T11:03:50-01:00*/

/********************************************************************
 * cam_computation.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "cam_computation.h"




typedef struct camTableStruct
{  
	float master[7000];
	float slave[7000];
} camTableStruct;

camTableStruct *camTable;

/**************************** Variables *****************************/

CB_Index cam_computation__num = 0;
CB_Mem_Int *cam_computation_profileNr;
CB_Mem_Float *cam_computation_MasterPositionIn;
CB_Mem_Int *cam_computation_nbPoints0;
CB_Mem_Float *cam_computation_MasterPoints0;
CB_Mem_Float *cam_computation_SlavePoints0;
CB_Mem_Int *cam_computation_pointer0;
CB_Mem_Int *cam_computation_nbPoints1;
CB_Mem_Float *cam_computation_MasterPoints1;
CB_Mem_Float *cam_computation_SlavePoints1;
CB_Mem_Int *cam_computation_pointer1;
CB_Mem_Int *cam_computation_nbPoints2;
CB_Mem_Float *cam_computation_MasterPoints2;
CB_Mem_Float *cam_computation_SlavePoints2;
CB_Mem_Int *cam_computation_pointer2;
CB_Mem_Int *cam_computation_nbPoints3;
CB_Mem_Float *cam_computation_MasterPoints3;
CB_Mem_Float *cam_computation_SlavePoints3;
CB_Mem_Int *cam_computation_pointer3;
CB_Mem_Float *cam_computation_slavePosition;
CB_Mem_Float *cam_computation_masterPosition;
CB_Mem_Int *cam_computation_i;
CB_Mem_Float *cam_computation_modulo;
CB_Mem_Int *cam_computation_divider;
CB_Mem_Bool *cam_computation_faultProfileNr;
CB_Mem_Bool *cam_computation_faultMasterPositionOOB;
CB_Mem_Bool *cam_computation_faultLinComputation;
CB_Mem_Int *cam_computation_nbPoints;
CB_Mem_Float *cam_computation_MasterPoints;
CB_Mem_Float *cam_computation_SlavePoints;
CB_Mem_Bool *cam_computation_found;
CB_Mem_Int *cam_computation_index;
CB_Mem_Float *cam_computation_linDenom;
CB_Mem_Float *cam_computation_linNum;
CB_Mem_Float *cam_computation_linA;
CB_Mem_Float *cam_computation_linB;
CB_Mem_Float *cam_computation_FACTOR;

/**************************** Variables *****************************/

#define profileNr (cam_computation_profileNr->CB_current_value)
#define MasterPositionIn (cam_computation_MasterPositionIn->CB_current_value)
#define nbPoints0 (*((short *)&(cam_computation_nbPoints0->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MasterPoints0(i) (cam_computation_MasterPoints0[i+1].CB_current_value)
#define SlavePoints0(i) (cam_computation_SlavePoints0[i+1].CB_current_value)
#define pointer0 (cam_computation_pointer0->CB_current_value)
#define nbPoints1 (*((short *)&(cam_computation_nbPoints1->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MasterPoints1(i) (cam_computation_MasterPoints1[i+1].CB_current_value)
#define SlavePoints1(i) (cam_computation_SlavePoints1[i+1].CB_current_value)
#define pointer1 (cam_computation_pointer1->CB_current_value)
#define nbPoints2 (*((short *)&(cam_computation_nbPoints2->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MasterPoints2(i) (cam_computation_MasterPoints2[i+1].CB_current_value)
#define SlavePoints2(i) (cam_computation_SlavePoints2[i+1].CB_current_value)
#define pointer2 (cam_computation_pointer2->CB_current_value)
#define nbPoints3 (*((short *)&(cam_computation_nbPoints3->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MasterPoints3(i) (cam_computation_MasterPoints3[i+1].CB_current_value)
#define SlavePoints3(i) (cam_computation_SlavePoints3[i+1].CB_current_value)
#define pointer3 (cam_computation_pointer3->CB_current_value)
#define slavePosition (cam_computation_slavePosition->CB_current_value)
#define masterPosition (cam_computation_masterPosition->CB_current_value)
#define i (*((short *)&(cam_computation_i->CB_current_value) + ALIGN_OFFSET_SHORT))
#define modulo (cam_computation_modulo->CB_current_value)
#define divider (*((short *)&(cam_computation_divider->CB_current_value) + ALIGN_OFFSET_SHORT))
#define faultProfileNr (cam_computation_faultProfileNr->CB_current_value)
#define faultMasterPositionOOB (cam_computation_faultMasterPositionOOB->CB_current_value)
#define faultLinComputation (cam_computation_faultLinComputation->CB_current_value)
#define nbPoints (*((short *)&(cam_computation_nbPoints->CB_current_value) + ALIGN_OFFSET_SHORT))
#define MasterPoints(i) (cam_computation_MasterPoints[i+1].CB_current_value)
#define SlavePoints(i) (cam_computation_SlavePoints[i+1].CB_current_value)
#define found (cam_computation_found->CB_current_value)
#define index (*((short *)&(cam_computation_index->CB_current_value) + ALIGN_OFFSET_SHORT))
#define linDenom (cam_computation_linDenom->CB_current_value)
#define linNum (cam_computation_linNum->CB_current_value)
#define linA (cam_computation_linA->CB_current_value)
#define linB (cam_computation_linB->CB_current_value)
#define FACTOR (cam_computation_FACTOR->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _motion_lib__cam_computation_init(void)
{
	(self.Float+209)->CB_current_value = 1.0; /*FACTOR*/
	self.Bool+=4;
	self.Int+=4;
	self.Float+=210;


	return 0;
}


/************************ Behavior function *************************/

int motion_lib__cam_computation(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		cam_computation_i = self.Int+0;
		cam_computation_modulo = self.Float+0;
		cam_computation_divider = self.Int+1;
		cam_computation_faultProfileNr = self.Bool+0;
		cam_computation_faultMasterPositionOOB = self.Bool+1;
		cam_computation_faultLinComputation = self.Bool+2;
		cam_computation_nbPoints = self.Int+2;
		cam_computation_MasterPoints = self.Float+1;
		cam_computation_SlavePoints = self.Float+103;
		cam_computation_found = self.Bool+3;
		cam_computation_index = self.Int+3;
		cam_computation_linDenom = self.Float+205;
		cam_computation_linNum = self.Float+206;
		cam_computation_linA = self.Float+207;
		cam_computation_linB = self.Float+208;
		cam_computation_FACTOR = self.Float+209;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category : motion_control						*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2021							*/
			/* ----------------------------------------------------------------	*/
			/* This module do the Slave cam computation from one Master position	*/
			/* The profile table inputs are provided by the module cam_profile	*/
			/* It's possible to switch in real time between 4 different profiles	*/
			/* ----------------------------------------------------------------	*/


			if (profileNr<0 || profileNr>3) {
				faultProfileNr = 1;
			} else {
				faultProfileNr = 0;
				if (profileNr==0 && nbPoints0) {
					camTable = pointer0;
					nbPoints = nbPoints0;
					for (i=1; i< 100; i++) {
						MasterPoints(i) = camTable->master[i-1];
						SlavePoints(i) = camTable->slave[i-1];
					}
					modulo = camTable->master[nbPoints-1];
				} else {
					if (profileNr==1 && nbPoints1) {
						camTable = pointer1;
						nbPoints = nbPoints1;
						for (i=1; i< 100; i++) {
							MasterPoints(i) = camTable->master[i-1];
							SlavePoints(i) = camTable->slave[i-1];
						}
						modulo = camTable->master[nbPoints-1];
					} else {
						if (profileNr==2 && nbPoints2) {
							camTable = pointer2;
							nbPoints = nbPoints2;
							for (i=1; i< 100; i++) {
								MasterPoints(i) = camTable->master[i-1];
								SlavePoints(i) = camTable->slave[i-1];
							}
							modulo = camTable->master[nbPoints-1];
						} else {
							if (profileNr==3 && nbPoints3) {
								camTable = pointer3;
								nbPoints = nbPoints3;
								for (i=1; i< 100; i++) {
									MasterPoints(i) = camTable->master[i-1];
									SlavePoints(i) = camTable->slave[i-1];
								}
								modulo = camTable->master[nbPoints-1];
							}
						}
					}
				}
				if (nbPoints >= 2) {
					masterPosition = MasterPositionIn - divider * modulo;
					while (masterPosition > modulo) {
						divider += 1;
						masterPosition = MasterPositionIn - divider * modulo;
					}
					while (masterPosition < 0) {
						divider -= 1;
						masterPosition = MasterPositionIn - divider * modulo;
					}
					found = 0;
					for (i=1; i<= nbPoints - 1 && found == 0; i++) {
						if (camTable->master[i-1] <= masterPosition && masterPosition <= camTable->master[i]) {
							index = i;
							found = 1;
						} 
					}
					if (!found) {
						faultMasterPositionOOB = 1;
						if (masterPosition < camTable->master[0]) {
							slavePosition = camTable->slave[0] * FACTOR;
						} else {
							slavePosition = SlavePoints(nbPoints) * FACTOR;
						}
					} else {
						linDenom = camTable->master[index] - camTable->master[index-1];
						if (linDenom != 0.0) {
							faultLinComputation = 0;
							linNum = camTable->slave[index] - camTable->slave[index-1];
							linA = linNum / linDenom;
							linB = camTable->slave[index-1] - (linA * camTable->master[index-1]);
							slavePosition = FACTOR * (linA * masterPosition + linB);
						} else {
							faultLinComputation = 1;
						}
					}
				} else {
					slavePosition = 0;
				}
			}



		}

		CB_post_float(cam_computation_slavePosition);
		CB_post_float(cam_computation_masterPosition);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 4;
	self.Int += 4;
	self.Float += 210;

	return 0;
}


/*2023-10-04T11:03:51-01:00*/

/********************************************************************
 * pusher.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"
#include "cb_products_iec.h"

#include "pusher.h"


/**************************** Variables *****************************/

CB_Index pusher__num = 0;
CB_Mem_Float *pusher_moveX;
CB_Mem_Float *pusher_moveY;
CB_Mem_Float *pusher_moveZ;
CB_Mem_Int *pusher_status_act_prod;
CB_Mem_Float *pusher_m11;
CB_Mem_Float *pusher_m12;
CB_Mem_Float *pusher_m13;
CB_Mem_Float *pusher_m14;
CB_Mem_Float *pusher_m21;
CB_Mem_Float *pusher_m22;
CB_Mem_Float *pusher_m23;
CB_Mem_Float *pusher_m24;
CB_Mem_Float *pusher_m31;
CB_Mem_Float *pusher_m32;
CB_Mem_Float *pusher_m33;
CB_Mem_Float *pusher_m34;
CB_Mem_Float *pusher_m41;
CB_Mem_Float *pusher_m42;
CB_Mem_Float *pusher_m43;
CB_Mem_Float *pusher_m44;
CB_Mem_Float *pusher_moveX1;
CB_Mem_Float *pusher_moveY1;
CB_Mem_Float *pusher_moveZ1;
CB_Mem_Float *pusher_oriX;
CB_Mem_Float *pusher_oriY;
CB_Mem_Float *pusher_oriZ;

/**************************** Variables *****************************/

#define moveX (pusher_moveX->CB_current_value)
#define moveY (pusher_moveY->CB_current_value)
#define moveZ (pusher_moveZ->CB_current_value)
#define status_act_prod (pusher_status_act_prod->CB_current_value)
#define m11 (pusher_m11->CB_current_value)
#define m12 (pusher_m12->CB_current_value)
#define m13 (pusher_m13->CB_current_value)
#define m14 (pusher_m14->CB_current_value)
#define m21 (pusher_m21->CB_current_value)
#define m22 (pusher_m22->CB_current_value)
#define m23 (pusher_m23->CB_current_value)
#define m24 (pusher_m24->CB_current_value)
#define m31 (pusher_m31->CB_current_value)
#define m32 (pusher_m32->CB_current_value)
#define m33 (pusher_m33->CB_current_value)
#define m34 (pusher_m34->CB_current_value)
#define m41 (pusher_m41->CB_current_value)
#define m42 (pusher_m42->CB_current_value)
#define m43 (pusher_m43->CB_current_value)
#define m44 (pusher_m44->CB_current_value)
#define moveX1 (pusher_moveX1->CB_current_value)
#define moveY1 (pusher_moveY1->CB_current_value)
#define moveZ1 (pusher_moveZ1->CB_current_value)
#define oriX (pusher_oriX->CB_current_value)
#define oriY (pusher_oriY->CB_current_value)
#define oriZ (pusher_oriZ->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _motion_lib__pusher_init(void)
{
	(self.Float+0)->CB_current_value = 1.0; /*m11*/
	(self.Float+5)->CB_current_value = 1.0; /*m22*/
	(self.Float+10)->CB_current_value = 1.0; /*m33*/
	(self.Float+15)->CB_current_value = 1.0; /*m44*/
	(self.Float+19)->CB_current_value = 1.0; /*oriX*/
	(self.Float+20)->CB_current_value = 1.0; /*oriY*/
	(self.Float+21)->CB_current_value = 1.0; /*oriZ*/
	self.Int+=1;
	self.Float+=22;


	return 0;
}


/************************ Behavior function *************************/

int motion_lib__pusher(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		pusher_status_act_prod = self.Int+0;
		pusher_m11 = self.Float+0;
		pusher_m12 = self.Float+1;
		pusher_m13 = self.Float+2;
		pusher_m14 = self.Float+3;
		pusher_m21 = self.Float+4;
		pusher_m22 = self.Float+5;
		pusher_m23 = self.Float+6;
		pusher_m24 = self.Float+7;
		pusher_m31 = self.Float+8;
		pusher_m32 = self.Float+9;
		pusher_m33 = self.Float+10;
		pusher_m34 = self.Float+11;
		pusher_m41 = self.Float+12;
		pusher_m42 = self.Float+13;
		pusher_m43 = self.Float+14;
		pusher_m44 = self.Float+15;
		pusher_moveX1 = self.Float+16;
		pusher_moveY1 = self.Float+17;
		pusher_moveZ1 = self.Float+18;
		pusher_oriX = self.Float+19;
		pusher_oriY = self.Float+20;
		pusher_oriZ = self.Float+21;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Actor Myself init *************************/

		setMyselfFor(self_num);

		/************************ Behavior execution ************************/

		{
			moveX1 = moveX * oriX;
			moveY1 = moveY * oriY;
			moveZ1 = moveZ * oriZ;
			moveBy_OUT(myself, moveX1, moveY1, moveZ1);
		}

		if(nb_alloc > 0) {
			free_all_alloc();
		}


		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Int += 1;
	self.Float += 22;

	return 0;
}

